import os.path as osp
import random
import libnum
import time
from PIL import Image
import hashlib

start = time.time()

n = 997


def pickg(p: int):
    for x in range(1, p):
        rand = x
        exp = 1
        next = rand % p

        while (next != 1):
            next = (next*rand) % p
            exp = exp+1

        if (exp == p-1):
            return int(rand)


def binaryFormation(bit_size: int, fPath: str):
    binaryList = []
    file = open(osp.join(fPath, f"{bit_size}bit.csv"), "r")
    while True:
        data = file.readline()
        if "" == data:
            print("EOF file reached.")
            break
        else:
            binaryList.append(data.replace(",", "").replace(
                "-1", "0").replace("\n", ""))
    return binaryList


def x_generator(bitNum: int, hashType: str, imageNum: int):
    if hashType == "nh" or hashType == "neuralhash":
        if bitNum == 16:
            return int(bit_16[list(imageDataset)[imageNum]], 10)
        elif bitNum == 32:
            return int(bit_32[list(imageDataset)[imageNum]], 10)
        elif bitNum == 48:
            return int(bit_48[list(imageDataset)[imageNum]], 10)
        else:
            print("invalid bit num")
    elif hashType == "md5":
        return int(hashlib.md5(Image.open(f"../data/nus_wide/{list(imageDataset.values())[imageNum]}").tobytes()).hexdigest(), 16)
    elif hashType == "sha256":
        return int(hashlib.sha256(Image.open(f"../data/nus_wide/{list(imageDataset.values())[imageNum]}").tobytes()).hexdigest(), 16)


fPath = "../snapshot/binary"

# binary hash generation list. Remove the "#" to init the list.
# bit_16 = binaryFormation(16, fPath)
# bit_32 = binaryFormation(32, fPath)
# bit_48 = binaryFormation(48, fPath)

#randomly selected 5 images for testing
imageDataset = {0: "/images/36051_1116992165_ab0704971e_m.jpg", 9: "/images/99215_2681193946_b497531f7b_m.jpg",
                14: "/images/28489_833495994_5aac2333a9_m.jpg", 30: "/images/244767_2216079512_004ffbb960_m.jpg", 137: "/images/82376_1288242246_e8fe0046fa_m.jpg"}

# Challenge generated by the verifier
c = random.randint(1, n)

# Generation of random value by prover
m = random.randint(1, n)

x = x_generator(0, "md5", 0)


g = pickg(n)
y = pow(g, x, n)  # registration
t = pow(g, m, n)  # access value
r = m-(c*x)
if (r < 0):
    u = (libnum.invmod(pow(g, -r, n), n) * pow(y, c, n)) % n
else:
    u = (pow(g, r, n) * pow(y, c, n)) % n
if u == t:
    print("Auth success!")
else:
    print(f"g = {g} \ny = {y} \nt={t} \nr={r} \nu={u} \nn={n}")

end = time.time()
print(end-start)
# print(bit_16)
# print(len(bit_16), len(bit_32), len(bit_48))
